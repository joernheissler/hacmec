#!/usr/bin/env python


from time import sleep
from asyncio import run
from hacmec.http import aiohttp
from hacmec import ENDPOINT_LETSENCRYPT_STAGING
from hacmec.client import Hacmec, dns as dnsid, AcmeChallengeDns01


from collections import deque
from cryptokey.backend.cryptography import backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptokey.backend.cryptography.rsa import RsaPrivateKey
from cryptokey.public.rsa import RsaScheme
from cryptokey.hashes import sha2_256
from cryptography.hazmat.primitives import serialization
from asyncio import run

import json
import dns.query
import dns.tsigkeyring
import dns.update
import dns.resolver
from dns.tsig import HMAC_SHA256

from base64 import b64encode

from cryptography import x509
from cryptography.hazmat.primitives import hashes
from cryptography.x509.oid import NameOID


def update_dns(host, key_name, secret, domain, records): 
    keyring = dns.tsigkeyring.from_text({key_name: b64encode(secret.encode()).decode()})
    update = dns.update.Update(domain, keyring=keyring, keyalgorithm=HMAC_SHA256)

    for dom, value in records.items():
        dom = dom.rstrip('.')
        if not dom.endswith(domain):
            raise ValueError(dom)
        dom = dom[:-len(domain)]
        dom = dom.rstrip('.')
        print(f'{dom} -> {value}')
        update.replace(dom, 60, 'txt', '"' + value + '"')

    dns.query.tcp(update, host)


def poll_dns(ns, records):
    ns_ips = list(map(resolve_a, ns))
    
    todo = deque((ip, fqdn, value) for ip in ns_ips for fqdn, value in records.items())
    print('Poll DNS:')
    jprint(list(todo))

    while todo:
        job = todo.popleft()
        value = resolve_txt(job[1], job[0])
        if value == job[2]:
            print(f'{job} done!')
            continue
        print(f'Not yet ok: {job}')
        todo.append(job)
        sleep(5)


def resolve_a(name):
    for i in range(10):
        try:
            return dns.resolver.query(name, 'A')[0].address
        except Exception as ex:
            print(ex)
            sleep(5)


def resolve_txt(name, server):
    try:
        return dns.query.udp(dns.message.make_query(name, 'TXT'), server).answer[0][0].strings[0].decode()
    except Exception as ex:
        print(ex)
        return None


def get_csr(keyfile: str, domains) -> bytes:
    try:
        with open(keyfile, 'rb') as fp:
            key_pem = fp.read()
    except FileNotFoundError:
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=4096, backend=backend)
        with open(keyfile, 'wb') as fp:
            fp.write(private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            ))
    else:
        private_key = serialization.load_pem_private_key(key_pem, password=None, backend=backend)


    return (
        x509.CertificateSigningRequestBuilder()
        .subject_name(x509.Name([
            x509.NameAttribute(NameOID.COMMON_NAME, domains[0]),
        ]))
        .add_extension(
            x509.SubjectAlternativeName(list(map(x509.DNSName, domains))),
            critical=False,
        )
        .sign(private_key, hashes.SHA256(), backend)
        .public_bytes(serialization.Encoding.DER)
    )


def jprint(val):
    print(json.dumps(val, indent=4, sort_keys=True))
    print()


def load_key(fname: str) -> RsaPrivateKey:
    with open(fname, 'rb') as fp:
        key = RsaPrivateKey(serialization.load_pem_private_key(fp.read(), None, backend))
        key.default_scheme = RsaScheme.PKCS1v1_5
        key.default_hash_algorithm = sha2_256()
        return key


async def prog(acme: Hacmec) -> None:
    with open('wild.json', 'rt') as fp:
        config = json.load(fp)

    csr = get_csr(config['key'], config['ids'])

    await acme.load_directory(config['directory'])
    acc_key = load_key(config['account'])
    acc = await acme.find_account(acc_key)
    print('Account:')
    jprint(acc.data)

    order = await acc.new_order(map(dnsid, config['ids']))
    print(f'Order "{order.url}":')
    jprint(order.data)

    records = {}

    for auth in order.authorizations:
        await auth.update()
        print('Authorization:')
        jprint(auth.data)

        for chall in auth.challenges:
            if not isinstance(chall, AcmeChallengeDns01):
                continue
            records[chall.fqdn] = chall.txt_record

    print('DNS Updates:')
    jprint(records)

    update_dns(config['tsig_host'], config['tsig_name'], config['tsig_key'], config['tsig_dom'], records)
    poll_dns(config['dns'], records)

    for auth in order.authorizations:
        for chall in auth.challenges:
            if not isinstance(chall, AcmeChallengeDns01):
                continue
            await chall.respond()

    broken = False
    while True:
        done = True
        for auth in order.authorizations:
            if auth.status == 'pending':
                await auth.update()

            if auth.status == 'pending':
                done = False
            elif auth.status != 'valid':
                broken = True
        if done:
            break
        sleep(5)

    for auth in order.authorizations:
        print('Authorization:')
        jprint(auth.data)

    if broken:
        raise Exception()


    while order.status == 'pending':
        await order.update()
        if order.status == 'pending':
            sleep(5)

    print('Order:')
    jprint(order.data)
    if order.status != 'ready':
        raise Exception()

    await order.send_csr(csr)

    while order.status == 'processing':
        await order.update()
        if order.status == 'processing':
            sleep(5)

    print('Order:')
    jprint(order.data)
    if order.status != 'valid':
        raise Exception()

    cert = await order.download()

    with open(config['cert'], 'wb') as fp:
        fp.write(cert)

  # jprint(order.data)

    # auth = order.authorizations[0]
    # await auth.update()
    # jprint(auth.data)
#   for chall in auth.challenges:
#       if not isinstance(chall, AcmeChallengeDns01):
#           continue
#       await chall.respond()
#   await auth.update()
#   jprint(auth.data)


async def main() -> None:
    async with aiohttp.AioHttpClient('WulfIsTesting/0.1', 'de, en;q=0.5') as http:
        await prog(Hacmec(http))


run(main())
